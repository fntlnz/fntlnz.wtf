<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <link rel="stylesheet" href='/css/style.css?v4'>
    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://fntlnz.wtf/index.xml">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Condensed" rel="stylesheet">
    <meta property="og:url" content="https://fntlnz.wtf/post/what-i-learnt-about-kubernetes-controller/">
    
    <meta property="og:type" content="article">
    <meta property="og:title" content="What I learnt about Kubernetes Controllers - Lorenzo Fontana&#39;s Homepage">
    <meta property="og:image" content="https://fntlnz.wtf/gdb-go/gdb-dashboard.jpg" />
    <meta property="og:description" content="Some stuff I learnt about kubernetes controllers while working on an issue around Storage" />
    
    <title>What I learnt about Kubernetes Controllers</title>
    <link rel="apple-touch-icon" sizes="57x57" href="/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
    <link rel="manifest" href="/favicon/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">

  </head>
  <body>

<header class="topBarSingle">
  <a href="/">↜ back to home</a>
</header>
<article>
  <section id="title">
    <h1>What I learnt about Kubernetes Controllers</h1>
    <time>Lorenzo Fontana, Sep 5, 2018, 5 min read</time>
  </section>
  <section id="content"><p>If you are a Kubernetes Controller you know that your main duty is to react to changes to the world’s desired state and actual state to do whatever you can to update the latter so that it matches the former.</p>

<p>When I think about my early steps with Kubernetes two things comes to mind related to Controllers:</p>

<ul>
<li>That everyone used the <code>ReplicationController</code> because we didn’t have <code>Deployment</code></li>
<li>The hard times to have the controller manager working in my clusters.</li>
</ul>

<p>Said that, I was sure I knew everything about controllers myself but just realized I never had the opportunity to learn what they actually do underneath until recently when I had a peak of interest after opening issue <a href="https://github.com/kubernetes/kubernetes/issues/67342">#67342</a> titled “Storage: devicePath is empty while WaitForAttach in StatefulSets”.</p>

<p>While trying to reproduce, I encountered a set of call to functions that were happening through some files named with very explanatory names:</p>

<pre><code>actual_state_of_world.go:616 -&gt;
  reconciler.go:238 -&gt;
    operation_executor.go:712 -&gt;
       operation_generator.go:437 -&gt; error on line 496
</code></pre>

<p>This looked very similar to a definition I found in the <em>&ldquo;Standardized Glossary&rdquo;</em> here.</p>

<blockquote>
<p>A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.
Examples of controllers that ship with Kubernetes today are the replication controller, endpoints controller, namespace controller, and serviceaccounts controller.</p>
</blockquote>

<p>Nice so the <a href="https://github.com/kubernetes/kubernetes/blob/6cc7b1cd3aac5c9abd6fc1416b16f9c141b6ff14/pkg/kubelet/volumemanager/volume_manager.go#L98"><code>VolumeManager</code></a> is not really a controller but conceptually it behaves in a very similar way since it has a loop, a reconciler, a desired state and an actual state.</p>

<p>At this point I started looking at all the projects both private and public I touched and among the public ones I recognized a very interesting pattern they all had a <code>cache.ListWatch</code> and a <code>cache.SharedInformer</code>.</p>

<p>The interesting part was that most of them also had a <code>workqueue.Interface</code> like the <a href="https://github.com/coreos/etcd-operator/blob/c8f63d508266990a4d20718d94363c30e75e6282/pkg/controller/backup-operator/controller.go#L37">etcd operator controller</a>, the <a href="https://github.com/kubernetes/ingress-nginx/blob/29c5d770688b04d0a8beedf70aebd76990332d56/internal/task/queue.go#L41">NGINX ingress controller</a> and the <a href="https://github.com/openfaas-incubator/openfaas-operator/blob/a928752c5cd0429330c9474b834ea63d29741185/pkg/controller/controller.go#L66">OpenFaas Operator Controller</a> and it turns out that they use it because it’s a key component in ensuring that the state is consistent and that all the controller’s instances agree on a shared set of elements to be processed with certain constraints (this looks very close to that Glossary’s definition above!).</p>

<p>While writing this post I was tempted to write a full length example but I found an already available <a href="https://github.com/kubernetes/kubernetes/tree/53ee0c86522b1afc1ee64503c73965b89d500db5/staging/src/k8s.io/sample-controller">exhaustive example</a> in the kubernetes repo so i will just write and go through the simplest self-contained example I can write.</p>

<p>Scroll to the end of the controller example to read about it.</p>

<script src="https://gist.github.com/fntlnz/65ec4e7273b15e858dda97c0f6f2241b.js"></script>

<p>The main components of this Controller are:</p>

<ul>
<li>The Workqueue (I would say, the reconciler or the thing that coordinates the synchronization from the actual state of the world to the desired state of the world)</li>
<li><code>syncToStdout</code>: The logic used to make changes to the actual state of the world</li>
<li>The SharedInformer: From the glossary’s definition — A control loop that watches the shared state</li>
</ul>

<p>In the SharedInformer I define some handlers to deal with <code>Add</code>, <code>Delete</code> and <code>Update</code> but instead of using them directly I synchronize what they receive into a workqueue with <code>queue.Add</code></p>

<pre><code class="language-go">AddFunc: func(obj interface{}) {
   key, err := cache.MetaNamespaceKeyFunc(obj)
   if err == nil {
    queue.Add(key)
   }
 },
</code></pre>

<p>The Workqueue is a structure that allows to queue changes for a specific resource and process them later in multiple workers with the guarantee that there will be no more than one worker working on a specific item at the same moment.
In fact the elements are processed in <code>runWorker</code> and multiple workers are started by increasing the <code>threadiness</code> parameter of the Controller’s Run method.</p>

<p>In this way I can end up in <code>syncToStdout</code> and be sure I will be the only one processing that item while knowing that if the current process gives an error my operation will be repeated up to an hardcoded limit of 5 times as defined in <code>handleErr</code>.</p>

<p>In this situation every item has an exponential backoff rate limit so that failures are not retried immediately but after a calculated amount of time that increases depending on the specified factor (I used DefaultControllerRateLimiter here but it’s very easy to create your own with chosen parameters).</p>

<p>This rate limit mechanism can be very helpful if we added a call to an external API every time we are informed about a pod. In such case the external API might impose a rate limit to our calls resulting in a failed behavior right now that will be perfectly fine after retrying in a while.</p>

<p>The Indexer and the Informer are also key components to use the process workqueue elements here because we want to be Informed about events occurring for the resources Kind we are interested in (in this case: Pod) and we want to have an Index where we can lookup for the final Pod object.</p>

<p>But hey, since we used the SharedInformer so we don’t need to provide an indexer ourselves because our beloved informer already contains one in <code>GetStore()</code>.</p>

<p>Another aspect of using the SharedInformer here is that we are guaranteed that the element we get from its internal indexer is at least as fresh as the event we received.</p>

<p>Wow, I don’t think I know everything about controllers now but I’m still in the peak of interest so I will probably follow with more stuff on the topic.</p>
</section>
</article>

</body>
</html>

