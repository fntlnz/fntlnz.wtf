<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Lorenzo Fontana&#39;s Homepage</title>
    <link>https://fntlnz.wtf/</link>
    <language>en-US</language>
    <author>Lorenzo Fontana</author>
    <updated>Wed, 12 Jun 2019 00:00:00 CEST</updated>
    
    <item>
      <title>Load XDP programs using the ip (iproute2) command</title>
      <link>https://fntlnz.wtf/post/xdp-ip-iproute/</link>
      <pubDate>Mon, 08 Oct 2018 10:35:53 CEST</pubDate>
      <author>Lorenzo Fontana</author>
      <guid>https://fntlnz.wtf/post/xdp-ip-iproute/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Nota bene:&lt;/strong&gt; If you don’t even know what XDP is, continue reading I will explain it later.&lt;/p&gt;

&lt;h3 id=&#34;my-journey&#34;&gt;My journey&lt;/h3&gt;

&lt;p&gt;Past week I was working on a piece of software that needed the ability to define some custom network paths to route HTTP traffic to multiple destinations based on rules defined on a data store.&lt;/p&gt;

&lt;p&gt;During the first phase, I had the opportunity to go through different ideas, and since my end result &lt;strong&gt;needed to be very fast and able to handle high throughput&lt;/strong&gt;, in my mind there was only one thing “XDP”.
I already used XDP in the past working at a similar project and my knowledge about eBPF was already good enough that my team agreed this was crazy and thus we decided we should try.&lt;/p&gt;

&lt;p&gt;I’m aware of, and I usually use &lt;a href=&#34;https://github.com/iovisor/bcc&#34;&gt;iovisor/bcc&lt;/a&gt; or &lt;code&gt;libbpf&lt;/code&gt; directly, but this time, I wanted something I can use to validate some ideas first, debug some of that code and only later include my program in a more complete project.&lt;/p&gt;

&lt;p&gt;Even if usually pay a lot of attention to LKML, lwn.net and in general, to relevant projects in this area like &lt;a href=&#34;http://github.com/cilium/cilium&#34;&gt;Cilium&lt;/a&gt; I didn’t know that the &lt;code&gt;ip&lt;/code&gt; command was able to load XDP programs since last week when I was lucky enough to be in &lt;code&gt;man 8 ip-link&lt;/code&gt; looking for something else and I found it! However, using it in that way wasn’t really straightforward (for me) and I had to spend quite some time to put all the pieces together so I decided to write this walkthrough.&lt;/p&gt;

&lt;h3 id=&#34;wait-wait-wait-what-is-xdp&#34;&gt;Wait wait wait.. What is XDP?&lt;/h3&gt;

&lt;p&gt;From the &lt;a href=&#34;https://iovisor.org&#34;&gt;iovisor.org&lt;/a&gt; website:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;XDP or eXpress Data Path provides a high performance, programmable network data path in the Linux kernel as part of the IO Visor Project. XDP provides bare metal packet processing at the lowest point in the software stack which makes it ideal for speed without compromising programmability. Furthermore, new functions can be implemented dynamically with the integrated fast path without kernel modification.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Cool, so XDP is a way to hook our eBPF programs very close to the network stack in order to do packets processing, encapsulation, de-encapsulation, get metrics etc..&lt;/p&gt;

&lt;p&gt;The important thing you need to know is that you can write a program, that gets loaded into the kernel as if it was a module but that can be loaded without modifying it.&lt;/p&gt;

&lt;p&gt;This kind program is called an eBPF program and is compiled to run against a special VM residing in the kernel that verifies and then executes those programs in a way that they cannot harm the running system.&lt;/p&gt;

&lt;p&gt;Note that eBPF programs &lt;strong&gt;are not Turing complete&lt;/strong&gt;, you can’t write loops for example.&lt;/p&gt;

&lt;p&gt;You can look at the diagram below to visualize how the loading of eBPF programs works.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://fntlnz.wtf/xdp-ip/0.png&#34; alt=&#34;eBPF load diagram&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Said all of that, &lt;strong&gt;XDP programs are a specialized kind of eBPF programs&lt;/strong&gt; with the additional capability to go lower level than kernel space by accessing driver space to act directly on packets.&lt;/p&gt;

&lt;p&gt;So if we wanted to visualize the same diagram from an XDP point of view it will look like this.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://fntlnz.wtf/xdp-ip/1.png&#34; alt=&#34;XDP load diagram&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In most cases, however your hardware may not support XDP so you will still be able to load XDP programs using the &lt;code&gt;xdpgeneric&lt;/code&gt; driver so you will still get the improvements of doing this lower level but not as with a network card that supports offloading network processing to it instead of doing that stuff on your CPU(s).&lt;/p&gt;

&lt;p&gt;If this is still very unclear you can read more about &lt;a href=&#34;https://www.iovisor.org/technology/xdp&#34;&gt;XDP here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;what-can-i-do-with-xdp&#34;&gt;What can I do with XDP?&lt;/h3&gt;

&lt;p&gt;This depends on how much imagination you have, some examples can be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Monitoring of the network packet flow by populating a map back to the userspace, look at &lt;a href=&#34;https://github.com/iovisor/gobpf/blob/master/examples/bcc/bash_readline/bash_readline.go&#34;&gt;this example&lt;/a&gt; if you need inspiration;&lt;/li&gt;
&lt;li&gt;Writing your own custom ingress/egress firewall like in the examples here;&lt;/li&gt;
&lt;li&gt;Rewrite packet destinations, packets re-routing;&lt;/li&gt;
&lt;li&gt;Packet inspection, security tools based on packets flowing;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;let-s-try-to-load-a-program&#34;&gt;Let’s try to load a program.&lt;/h3&gt;

&lt;h4 id=&#34;requirements&#34;&gt;Requirements:&lt;/h4&gt;

&lt;p&gt;You will need a Linux machine with Kernel &amp;gt; 4.8 with clang (&lt;a href=&#34;http://releases.llvm.org/3.7.0/docs/ReleaseNotes.html#bpf-compiler-collection-bcc&#34;&gt;llvm ≥ 3.7&lt;/a&gt;) , iproute2 and docker installed. 
Docker &lt;strong&gt;is not&lt;/strong&gt; needed to run XDP programs but it is used here because of three reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Docker by default creates bridged network interfaces on the host and on the container when you create a new container. Sick! I can point my XDP program to one of the bridged interfaces on the host.&lt;/li&gt;
&lt;li&gt;Since it creates network namespaces, I can access them again using the &lt;code&gt;ip&lt;/code&gt; command, since we are talking about that command here, this is a bonus for this post for me.&lt;/li&gt;
&lt;li&gt;I can run a web server featuring cats, the real force that powers the internet, and then I can then block traffic using XDP without asking you to compile, install or run anything else.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;step-0-create-a-docker-container-that-can-accept-some-http-traffic&#34;&gt;&lt;strong&gt;Step 0:&lt;/strong&gt; Create a docker container that can accept some HTTP traffic&lt;/h4&gt;

&lt;p&gt;So, let’s run caturday, we are not exposing the 8080 port for a reason!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker run --name httptest -d fntlnz/caturday
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-1-discover-the-ip-address-and-network-interface-for-httptest&#34;&gt;&lt;strong&gt;Step 1&lt;/strong&gt;: Discover the ip address and network interface for &lt;code&gt;httptest&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;Obtain the network namespace file descriptor from docker&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# sandkey=$(docker inspect httptest -f &amp;quot;{{.NetworkSettings.SandboxKey}}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prepare the network namespace to be inspected with the &lt;code&gt;ip&lt;/code&gt; command so that we can look at its network interfaces without using &lt;code&gt;docker exec&lt;/code&gt; .This also allows us to use any program we have in our root mount namespace against the container’s network. This is needed because the image we used &lt;code&gt;fntlnz/caturday&lt;/code&gt; does not contain &lt;code&gt;iproute2&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# mkdir -p /var/run/netns
# ln -s $sandkey /var/run/netns/httpserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;rsquo;t worry too much about that symlink, it will go away at next reboot. Now, let’s show the interfaces inside the container:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ip netns exec httpserver ip a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever71: eth0@if72: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The IP address is &lt;code&gt;172.17.0.2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Our interface &lt;code&gt;eth0&lt;/code&gt; in the container has id &lt;code&gt;71&lt;/code&gt; and is in pair with &lt;code&gt;if72&lt;/code&gt; so the ID in the host machine is just &lt;code&gt;72&lt;/code&gt;, let&amp;rsquo;s get the interface name in the host machine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ip a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool, the name is right there:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;72: vethcaf7146@if71: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue master docker0 state UP group default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So I have: IP: &lt;code&gt;172.17.0.2&lt;/code&gt;, Interface name on the host: &lt;code&gt;vethcaf7146&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;step-2-generate-some-traffic-to-go-to-the-interface-we-just-created-with-the-container-httptest&#34;&gt;&lt;strong&gt;Step 2:&lt;/strong&gt; Generate some traffic to go to the interface we just created with the container &lt;code&gt;httptest&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;For this purpose, we can use &lt;code&gt;hping3&lt;/code&gt; or the browser or even &lt;code&gt;curl&lt;/code&gt;. In this case I will be using &lt;code&gt;hping3&lt;/code&gt; because it continuously sends traffic to the interface and I can see how this changes after loading my XDP program.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# hping3 172.17.0.2 --fast
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In another terminal open &lt;code&gt;tcpdump&lt;/code&gt; to see the packet flow.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# tcpdump -i vethcaf7146
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;vethcaf7146&lt;/code&gt; is the name of the interface we found at step 2.&lt;/p&gt;

&lt;h4 id=&#34;step-3-compile-an-xdp-program-using-clang&#34;&gt;&lt;strong&gt;Step 3:&lt;/strong&gt; Compile an XDP program using clang&lt;/h4&gt;

&lt;p&gt;Let’s take this XDP program as an example &lt;em&gt;(there’s a more complete example later!)&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;linux/bpf.h&amp;gt;
int main() {
  return XDP_DROP;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compile it with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ clang -O2 -target bpf -c dropper.c -o dropper.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once loaded, this program drops every packet sent to the interface. If you change &lt;code&gt;XDP_DROP&lt;/code&gt; with &lt;code&gt;XDP_TX&lt;/code&gt; the packets will be sent back to the direction where they came from and you then change it to &lt;code&gt;XDP_PASS&lt;/code&gt;, the packets will just continue flowing.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;XDP_TX&lt;/code&gt; can also be used to transmit the packet to another destination if used after modifying the packet&amp;rsquo;s destination address, mac address and TCP checksum for example.&lt;/p&gt;

&lt;h4 id=&#34;step-4-load-the-dropper-o-program&#34;&gt;&lt;strong&gt;Step 4:&lt;/strong&gt; Load the dropper&lt;code&gt;.o&lt;/code&gt; program&lt;/h4&gt;

&lt;p&gt;At the previous step, we compiled &lt;code&gt;dropper.o&lt;/code&gt; from &lt;code&gt;dropper.c&lt;/code&gt;. We can now use the &lt;code&gt;ip&lt;/code&gt; command to load the program into the kernel.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ip link set dev vethcaf7146 xdp obj dropper.o sec .text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The careful reader may have noticed that we are using the &lt;code&gt;xdp&lt;/code&gt; flag in the previous command. That flag means that the kernel will do its best to load the XDP program on the network card as native. However not all the network cards support native XDP programs with hardware offloads, in that case, the kernel disables that.&lt;/p&gt;

&lt;p&gt;Hardware offloads happen when the network driver is attached to a network card that can process the networking work defined in the XDP program so that the server’s CPU doesn’t have to do that.&lt;/p&gt;

&lt;p&gt;In case you already know your card supports XDP you can use &lt;code&gt;xdpdrv&lt;/code&gt;, if you know that It doesn’t you can use &lt;code&gt;xdpgeneric&lt;/code&gt; .&lt;/p&gt;

&lt;h4 id=&#34;step-5-test-with-traffic-and-unload&#34;&gt;&lt;strong&gt;Step 5:&lt;/strong&gt; Test with traffic and unload&lt;/h4&gt;

&lt;p&gt;At this point, after loading the program you will notice that your &lt;code&gt;tcpdump&lt;/code&gt; started at Step 3 will stop receiving traffic because of the drop.&lt;/p&gt;

&lt;p&gt;You can now stop the XDP program by unloading it&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ip link set dev vethcaf7146 xdp off
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;step-6-drop-only-udp-packets&#34;&gt;Step 6: Drop only UDP packets&lt;/h4&gt;

&lt;p&gt;For the very simple use case we had (drop everything) we didn’t need to access the &lt;code&gt;xdp_md&lt;/code&gt; struct to get the context of the current packet flow, but now, since we want to selectively drop specific packets we need to do that.&lt;/p&gt;

&lt;p&gt;In order to do that, however, we need to declare a function that has &lt;code&gt;xdp_md *ctx&lt;/code&gt; as the first argument, to do that we need to use a different section than &lt;code&gt;.text&lt;/code&gt; when loading our program, let’s see the program below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;#include &amp;lt;linux/bpf.h&amp;gt;
#include &amp;lt;linux/in.h&amp;gt;
#include &amp;lt;linux/if_ether.h&amp;gt;
#include &amp;lt;linux/ip.h&amp;gt;

#define SEC(NAME) __attribute__((section(NAME), used))

SEC(&amp;quot;dropper_main&amp;quot;)
int dropper(struct xdp_md *ctx) {
  int ipsize = 0;

  void *data = (void *)(long)ctx-&amp;gt;data;
  void *data_end = (void *)(long)ctx-&amp;gt;data_end;

  struct ethhdr *eth = data;

  ipsize = sizeof(*eth);

  struct iphdr *ip = data + ipsize;
  ipsize += sizeof(struct iphdr);
  if (data + ipsize &amp;gt; data_end) {
    return XDP_PASS;
  }

  if (ip-&amp;gt;protocol == IPPROTO_UDP) {
    return XDP_DROP;
  }
  return XDP_PASS;
}

char _license[] SEC(&amp;quot;license&amp;quot;) = &amp;quot;GPL&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wow, a lot changed here!
First, we have a macro that allows us to map a section name to specific symbols, then we use that macro in &lt;code&gt;SEC(“dropper_main”)&lt;/code&gt; to point the section name &lt;code&gt;dropper_main&lt;/code&gt; to the dropper function where we accept the &lt;code&gt;xdp_md&lt;/code&gt; struct pointer. After that, there’s some boilerplate to extract the Ethernet frame from which we can then extract the information related to the packet like the protocol in this case that we use to check the protocol and drop all the UDP packets (line 26).&lt;/p&gt;

&lt;p&gt;Let’s compile it!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ clang -O2 -target bpf -c udp.c -o udp.o
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we can verify the symbol table with &lt;code&gt;objdump&lt;/code&gt; to see if our section is there.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objdump -t udp.o

udp.o:     file format elf64-little

SYMBOL TABLE:
0000000000000050 l       dropper_main   0000000000000000 LBB0_3
0000000000000000 g       license        0000000000000000 _license
0000000000000000 g       dropper_main   0000000000000000 dropper
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool, let’s load the function using the section &lt;code&gt;dropper_main&lt;/code&gt; always on the same interface we used before &lt;code&gt;vethcaf7146&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ip link set dev vethcaf7146 xdp obj udp.o sec dropper_main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nice! So let’s now try to do a DNS query from the container to verify if UDP packets are being dropped:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ip netns exec httpserver dig github.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should give nothing right now and &lt;code&gt;dig&lt;/code&gt; will be stuck for a while before exiting because there’s our XDP program that is dropping packets.&lt;/p&gt;

&lt;p&gt;Now we can unload that program and our DNS queries will be there again&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# dig github.com

;&amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.13.3 &amp;lt;&amp;lt;&amp;gt;&amp;gt; github.com
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 49708
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1&amp;lt;/pre&amp;gt;
; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 512
;; QUESTION SECTION:
;github.com.                    IN      A
;; ANSWER SECTION:
github.com.             59      IN      A       192.30.253.112
github.com.             59      IN      A       192.30.253.113
;; Query time: 42 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Sun Oct 07 23:10:53 CEST 2018
;; MSG SIZE  rcvd: 71
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h3&gt;

&lt;p&gt;When I first approached &lt;strong&gt;eBPF and XDP&lt;/strong&gt; one year ago I was very scared and my brain was telling sentences like&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I’m not going to learn this you fool!! ~ My brain, circa June 2017&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;However, after some initial pain and some months thinking about it I really enjoyed working on this stuff.&lt;/p&gt;

&lt;p&gt;But! As always I’m still in the process of learning stuff and this topic is very exciting and still very very obscure for me that I will surely try to do more stuff with this low-level unicorn.&lt;/p&gt;

&lt;p&gt;I hope you will enjoy working with XDP as much as I did and I hope my post here helped you going forward with your journey, as writing it did with mine.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I love this! ~ My brain, circa October 2018&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Following, some references for you.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/iovisor/bpf-docs&#34;&gt;https://github.com/iovisor/bpf-docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=JRFNIKUROPE&#34;&gt;https://www.youtube.com/watch?v=JRFNIKUROPE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kernel.org/doc/html/latest/networking/af_xdp.html&#34;&gt;https://www.kernel.org/doc/html/latest/networking/af_xdp.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cilium.readthedocs.io/en/latest/bpf/&#34;&gt;https://cilium.readthedocs.io/en/latest/bpf/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://suricata.readthedocs.io/en/latest/capture-hardware/ebpf-xdp.html?highlight=XDP&#34;&gt;https://suricata.readthedocs.io/en/latest/capture-hardware/ebpf-xdp.html?highlight=XDP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.netdevconf.org/2.1/slides/apr6/bertin_Netdev-XDP.pdf&#34;&gt;https://www.netdevconf.org/2.1/slides/apr6/bertin_Netdev-XDP.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Thanks for reading!&lt;/strong&gt; You can find me on &lt;a href=&#34;https://twitter.com/fntlnz&#34;&gt;Twitter&lt;/a&gt; and on &lt;a href=&#34;https://github.com/fntlnz&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>What I learnt about Kubernetes Controllers</title>
      <link>https://fntlnz.wtf/post/what-i-learnt-about-kubernetes-controller/</link>
      <pubDate>Wed, 05 Sep 2018 13:03:00 CEST</pubDate>
      <author>Lorenzo Fontana</author>
      <guid>https://fntlnz.wtf/post/what-i-learnt-about-kubernetes-controller/</guid>
      <description>&lt;p&gt;If you are a Kubernetes Controller you know that your main duty is to react to changes to the world’s desired state and actual state to do whatever you can to update the latter so that it matches the former.&lt;/p&gt;

&lt;p&gt;When I think about my early steps with Kubernetes two things comes to mind related to Controllers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;That everyone used the &lt;code&gt;ReplicationController&lt;/code&gt; because we didn’t have &lt;code&gt;Deployment&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The hard times to have the controller manager working in my clusters.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Said that, I was sure I knew everything about controllers myself but just realized I never had the opportunity to learn what they actually do underneath until recently when I had a peak of interest after opening issue &lt;a href=&#34;https://github.com/kubernetes/kubernetes/issues/67342&#34;&gt;#67342&lt;/a&gt; titled “Storage: devicePath is empty while WaitForAttach in StatefulSets”.&lt;/p&gt;

&lt;p&gt;While trying to reproduce, I encountered a set of call to functions that were happening through some files named with very explanatory names:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;actual_state_of_world.go:616 -&amp;gt;
  reconciler.go:238 -&amp;gt;
    operation_executor.go:712 -&amp;gt;
       operation_generator.go:437 -&amp;gt; error on line 496
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This looked very similar to a definition I found in the &lt;em&gt;&amp;ldquo;Standardized Glossary&amp;rdquo;&lt;/em&gt; here.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.
Examples of controllers that ship with Kubernetes today are the replication controller, endpoints controller, namespace controller, and serviceaccounts controller.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nice so the &lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/6cc7b1cd3aac5c9abd6fc1416b16f9c141b6ff14/pkg/kubelet/volumemanager/volume_manager.go#L98&#34;&gt;&lt;code&gt;VolumeManager&lt;/code&gt;&lt;/a&gt; is not really a controller but conceptually it behaves in a very similar way since it has a loop, a reconciler, a desired state and an actual state.&lt;/p&gt;

&lt;p&gt;At this point I started looking at all the projects both private and public I touched and among the public ones I recognized a very interesting pattern they all had a &lt;code&gt;cache.ListWatch&lt;/code&gt; and a &lt;code&gt;cache.SharedInformer&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The interesting part was that most of them also had a &lt;code&gt;workqueue.Interface&lt;/code&gt; like the &lt;a href=&#34;https://github.com/coreos/etcd-operator/blob/c8f63d508266990a4d20718d94363c30e75e6282/pkg/controller/backup-operator/controller.go#L37&#34;&gt;etcd operator controller&lt;/a&gt;, the &lt;a href=&#34;https://github.com/kubernetes/ingress-nginx/blob/29c5d770688b04d0a8beedf70aebd76990332d56/internal/task/queue.go#L41&#34;&gt;NGINX ingress controller&lt;/a&gt; and the &lt;a href=&#34;https://github.com/openfaas-incubator/openfaas-operator/blob/a928752c5cd0429330c9474b834ea63d29741185/pkg/controller/controller.go#L66&#34;&gt;OpenFaas Operator Controller&lt;/a&gt; and it turns out that they use it because it’s a key component in ensuring that the state is consistent and that all the controller’s instances agree on a shared set of elements to be processed with certain constraints (this looks very close to that Glossary’s definition above!).&lt;/p&gt;

&lt;p&gt;While writing this post I was tempted to write a full length example but I found an already available &lt;a href=&#34;https://github.com/kubernetes/kubernetes/tree/53ee0c86522b1afc1ee64503c73965b89d500db5/staging/src/k8s.io/sample-controller&#34;&gt;exhaustive example&lt;/a&gt; in the kubernetes repo so i will just write and go through the simplest self-contained example I can write.&lt;/p&gt;

&lt;p&gt;Scroll to the end of the controller example to read about it.&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/fntlnz/65ec4e7273b15e858dda97c0f6f2241b.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;The main components of this Controller are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The Workqueue (I would say, the reconciler or the thing that coordinates the synchronization from the actual state of the world to the desired state of the world)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;syncToStdout&lt;/code&gt;: The logic used to make changes to the actual state of the world&lt;/li&gt;
&lt;li&gt;The SharedInformer: From the glossary’s definition — A control loop that watches the shared state&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the SharedInformer I define some handlers to deal with &lt;code&gt;Add&lt;/code&gt;, &lt;code&gt;Delete&lt;/code&gt; and &lt;code&gt;Update&lt;/code&gt; but instead of using them directly I synchronize what they receive into a workqueue with &lt;code&gt;queue.Add&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;AddFunc: func(obj interface{}) {
   key, err := cache.MetaNamespaceKeyFunc(obj)
   if err == nil {
    queue.Add(key)
   }
 },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Workqueue is a structure that allows to queue changes for a specific resource and process them later in multiple workers with the guarantee that there will be no more than one worker working on a specific item at the same moment.
In fact the elements are processed in &lt;code&gt;runWorker&lt;/code&gt; and multiple workers are started by increasing the &lt;code&gt;threadiness&lt;/code&gt; parameter of the Controller’s Run method.&lt;/p&gt;

&lt;p&gt;In this way I can end up in &lt;code&gt;syncToStdout&lt;/code&gt; and be sure I will be the only one processing that item while knowing that if the current process gives an error my operation will be repeated up to an hardcoded limit of 5 times as defined in &lt;code&gt;handleErr&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this situation every item has an exponential backoff rate limit so that failures are not retried immediately but after a calculated amount of time that increases depending on the specified factor (I used DefaultControllerRateLimiter here but it’s very easy to create your own with chosen parameters).&lt;/p&gt;

&lt;p&gt;This rate limit mechanism can be very helpful if we added a call to an external API every time we are informed about a pod. In such case the external API might impose a rate limit to our calls resulting in a failed behavior right now that will be perfectly fine after retrying in a while.&lt;/p&gt;

&lt;p&gt;The Indexer and the Informer are also key components to use the process workqueue elements here because we want to be Informed about events occurring for the resources Kind we are interested in (in this case: Pod) and we want to have an Index where we can lookup for the final Pod object.&lt;/p&gt;

&lt;p&gt;But hey, since we used the SharedInformer so we don’t need to provide an indexer ourselves because our beloved informer already contains one in &lt;code&gt;GetStore()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Another aspect of using the SharedInformer here is that we are guaranteed that the element we get from its internal indexer is at least as fresh as the event we received.&lt;/p&gt;

&lt;p&gt;Wow, I don’t think I know everything about controllers now but I’m still in the peak of interest so I will probably follow with more stuff on the topic.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Post-mortem</title>
      <link>https://fntlnz.wtf/post/gopostmortem/</link>
      <pubDate>Tue, 16 Jan 2018 13:03:00 &#43;0200</pubDate>
      <author>Lorenzo Fontana</author>
      <guid>https://fntlnz.wtf/post/gopostmortem/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Even &lt;code&gt;if&lt;/code&gt; you write tests and those tests are perfect, effective and everything
you will face production issues. Sometimes everything will just crash and
when that&amp;rsquo;ll happen you&amp;rsquo;ll need some debugging skills.
Here I&amp;rsquo;m putting some flow examples, notes and resources around post-mortem debugging of
Go programs, including, but not limited to, those running inside a Kubernetes cluster.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m a huge fan of GDB, I used it for almost a decade now and while I remember
it was a bit clunky and difficult at first but it got better in the years
and in the meantime I got used to it and it&amp;rsquo;s commands and perks.&lt;/p&gt;

&lt;p&gt;A few years after my first gdb, I saw Delve and had the same feeling: it was clunky,
and it had nearly anything I needed. Now, after a couple of years Delve seems pretty
complete and it just works, one thing I really like about Delve is that even
if the terminal interface is similar to other debuggers (like gdb) has a very
well done UX, for example:&lt;/p&gt;

&lt;p&gt;This is the current execution point of a program under Delve:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-delve&#34;&gt;    29:         for {
    30:                 select {
    31:                 case message := &amp;lt;-ch:
    32:                         fmt.Println(message)
    33:                 case &amp;lt;-time.After(time.Second * 3):
=&amp;gt;  34:                         panic(&amp;quot;I&#39;m panicking because of timeout!&amp;quot;)
    35:                 }
    36:         }
    37: }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how the same thing looks like in GDB&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gdb&#34;&gt;30                      select {
31                      case message := &amp;lt;-ch:
32                              fmt.Println(message)
33                      case &amp;lt;-time.After(time.Second * 3):
34                              panic(&amp;quot;I&#39;m panicking because of timeout!&amp;quot;)
35                      }
36              }
37      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, one could extend GDB by customizing &lt;code&gt;.gdbinit&lt;/code&gt; like how the &lt;a href=&#34;https://github.com/cyrus-and/gdb-dashboard&#34;&gt;GDB Dashboard&lt;/a&gt; does:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://fntlnz.wtf/gdb-go/gdb-dashboard.jpg&#34; alt=&#34;GDB Dashboard Screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A part from the UX, Delve has several advantages over GDB when debugging Go:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It works out of the box - (Just Works™)&lt;/li&gt;
&lt;li&gt;Integrated with major editors: Vim/Nvim, Code, GoLand&lt;/li&gt;
&lt;li&gt;It has an impressivly well working support for Go concurrency patterns&lt;/li&gt;
&lt;li&gt;Even post-mortem core dump analysis works just right&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On the other hand, GDB has still some advantages over it:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It supports any architecture (Delve only amd64)&lt;/li&gt;
&lt;li&gt;It supports any OS (Delve only Linux, OSX and Windows)&lt;/li&gt;
&lt;li&gt;You can debug Cgo&lt;/li&gt;
&lt;li&gt;You need to extend your debugging to the Go runtime itself, GDB is your tool&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, how to say, I&amp;rsquo;m not very religious about the debugger I use but generally
when I need to choose Delve or GDB I just go with Delve and then if Delve breaks
I try with GDB. It&amp;rsquo;s not very scientific but it&amp;rsquo;s a wise way to proceed.&lt;/p&gt;

&lt;p&gt;I will show a few examples:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You need to debug an API server entirely written in Go, delve&lt;/li&gt;
&lt;li&gt;You need to debug some Go program orchestrating linux namespaces (like runc), delve breaks and I use GDB because in to interact with kernel features you need Cgo!&lt;/li&gt;
&lt;li&gt;You need to debug a program compiled for ppc64le? delve breaks, I use GDB&lt;/li&gt;
&lt;li&gt;You have a router mounting a mips processor and you want to debug your own DHCP written for it in Go? you know the debugger, true story.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;See it? Straightforward!&lt;/p&gt;

&lt;h1 id=&#34;proceed-with-the-autopsy&#34;&gt;Proceed with the Autopsy&lt;/h1&gt;

&lt;p&gt;When you do an autopsy over a crashed Go program there are two things you need:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A core dump&lt;/li&gt;
&lt;li&gt;A non-stripped, with DWARF and debug symbols binary of your program&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To get a core dump, the first thing you do is to check the maximum file size for a core dump file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ulimit -c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If it is zero, you are not core dumping so you need to raise the limit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ulimit -c unlimited
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also, when debugging, you have to remember that the Go runtime can be said
to trigger certain behavior that can make debugging easier.
In this case, we are interested to say the Go runtime to trigger a core dump
by actually doing a segfault instead of just exiting in case of panic.&lt;/p&gt;

&lt;p&gt;To do so, when we run the Go program we need to run it with &lt;code&gt;GOTRACEBACK=crash&lt;/code&gt; like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;GOTRACEBACK=crash ./myprogram
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are also other environment variables and behaviors for &lt;code&gt;GOTRACEBACK&lt;/code&gt;, if
you want to discover more take a look &lt;a href=&#34;https://golang.org/pkg/runtime/#hdr-Environment_Variables&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now that your system can core dump you need to restart the program and wait for it
to crash.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OR&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You can obtain the core file of a running program using &lt;code&gt;gcore&lt;/code&gt;,
see &lt;code&gt;man gcore&lt;/code&gt; for more info.&lt;/p&gt;

&lt;p&gt;Core files in linux are written with a template
defined in &lt;code&gt;/proc/sys/kernel/core_pattern&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cat /proc/sys/kernel/core_pattern
|/usr/lib/systemd/systemd-coredump %P %u %g %s %t %c %e
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In my case it is using the &lt;code&gt;systemd-coredump&lt;/code&gt; program to write files, and I get
lz4 compressed files like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;/var/lib/systemd/coredump/core.godebugging.1000.a0b55b870a3f443696cf7cb874d7f27b.32124.1515962062000000.lz4
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;production-just-got-hot&#34;&gt;Production just got hot&lt;/h1&gt;

&lt;p&gt;Generally speaking when a Go binary is built for production most of us
will use something similar to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;go build -ldflags &amp;quot;-s -w&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which has the effect of removing the
symbol table and DWARF symbol table from the program.&lt;/p&gt;

&lt;p&gt;Semi OT: if you are a digger, read &lt;a href=&#34;https://dave.cheney.net/2013/10/15/how-does-the-go-build-command-work&#34;&gt;this blog&lt;/a&gt;
from Dave Cheney on what the Go build command does, you&amp;rsquo;ll see a few interesting things.&lt;/p&gt;

&lt;p&gt;The good news is that we can analyze a core file with a binary built from
the same source code, this time without those ldflags.&lt;/p&gt;

&lt;h2 id=&#34;i-don-t-own-the-code&#34;&gt;I don&amp;rsquo;t own the code&lt;/h2&gt;

&lt;p&gt;But in case you don&amp;rsquo;t have or own the source be aware that without a symbol table
we can&amp;rsquo;t debug a program with Delve so with gdb and some Assembly skills you can
use gdb to use the binary you have with the core file you got from the production system,
then you can start analyzing what happened:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gdb&#34;&gt;gdb ./godebugging core.1234

[New LWP 32124]
[New LWP 32125]
[New LWP 32126]
[New LWP 32127]
[New LWP 32128]
Core was generated by `./godebugging&#39;.
Program terminated with signal SIGABRT, Aborted.
#0  0x0000000000455594 in ?? ()
[Current thread is 1 (LWP 32124)]

(gdb) bt
#0  0x0000000000455594 in ?? ()
#1  0x000000000043d10b in ?? ()
#2  0x0000000000000006 in ?? ()
#3  0x0000000000000000 in ?? ()

(gdb) x/30i $pc
0x455600:    sub    $0x18,%rsp
0x455604:    mov    %rbp,0x10(%rsp)
0x455609:    lea    0x10(%rsp),%rbp
0x45560e:    mov    0x10c96b(%rip),%rax        # 0x561f80
0x455615:    cmp    $0x0,%rax
0x455619:    je     0x45563f
0x45561b:    xor    %edi,%edi
0x45561d:    lea    (%rsp),%rsi
0x455621:    callq  *%rax
0x455623:    mov    (%rsp),%rax
0x455627:    mov    0x8(%rsp),%rdx
0x45562c:    mov    %rax,0x20(%rsp)
0x455631:    mov    %edx,0x28(%rsp)
0x455635:    mov    0x10(%rsp),%rbp
0x45563a:    add    $0x18,%rsp
0x45563e:    retq   
0x45563f:    lea    (%rsp),%rdi
0x455643:    xor    %esi,%esi
0x455645:    mov    0xdaa7c(%rip),%rax        # 0x5300c8
0x45564c:    callq  *%rax
0x45564e:    mov    (%rsp),%rax
0x455652:    mov    0x8(%rsp),%edx
0x455656:    imul   $0x3e8,%rdx,%rdx
0x45565d:    mov    %rax,0x20(%rsp)
0x455662:    mov    %edx,0x28(%rsp)
0x455666:    mov    0x10(%rsp),%rbp
0x45566b:    add    $0x18,%rsp
0x45566f:    retq   
0x455670:    sub    $0x18,%rsp
0x455674:    mov    %rbp,0x10(%rsp)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing I did was to use the &lt;code&gt;bt&lt;/code&gt; command to analyze how the backtrace looks
like, and then I showed the next 30 lines of Assembly with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gdb&#34;&gt;x/30i $pc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All this is not very useful unfortunately but in case of problems it can be of help.&lt;/p&gt;

&lt;h2 id=&#34;i-own-the-code&#34;&gt;I own the code&lt;/h2&gt;

&lt;p&gt;On the other hand if you own the code your life is just easier.&lt;/p&gt;

&lt;p&gt;In this situation, you&amp;rsquo;ll likely to have an optimized binary in production
that can&amp;rsquo;t be used for reading the core dump. If this is the case the thing you can do
is to compile the same source code without the optimizations and then use the debugger
to read the dump file along with it.&lt;/p&gt;

&lt;p&gt;With Delve&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;dlv core ./godebugging core.1234
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;(dlv) bt
0  0x0000000000455594 in runtime.raise
   at /usr/lib/go/src/runtime/sys_linux_amd64.s:113
1  0x0000000000451f70 in runtime.systemstack_switch
   at /usr/lib/go/src/runtime/asm_amd64.s:298
2  0x0000000000427ac8 in runtime.dopanic
   at /usr/lib/go/src/runtime/panic.go:586
3  0x000000000042765e in runtime.gopanic
   at /usr/lib/go/src/runtime/panic.go:540
4  0x00000000004952d9 in main.main
   at ./main.go:34
5  0x00000000004292a6 in runtime.main
   at /usr/lib/go/src/runtime/proc.go:195
6  0x00000000004545c1 in runtime.goexit
   at /usr/lib/go/src/runtime/asm_amd64.s:2337
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Things are so clear, &lt;code&gt;bt&lt;/code&gt; is showing that main.go broke at line 34
leading to a panic, let&amp;rsquo;s see what happened,
the problem seemed to be at frame 4 (the 4 in the backtrace), so I can print the source of that frame:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(dlv) frame 4 list
Goroutine 1 frame 4 at /home/fntlnz/go/src/github.com/fntlnz/godebugging/main.go:34 (PC: 0x4952d9)
    29:         for {
    30:                 select {
    31:                 case message := &amp;lt;-ch:
    32:                         fmt.Println(message)
    33:                 case &amp;lt;-time.After(time.Second * 3):
=&amp;gt;  34:                         panic(&amp;quot;I&#39;m panicking because of timeout!&amp;quot;)
    35:                 }
    36:         }
    37: }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wow! That&amp;rsquo;s a panic, I wrote it so that the program would crash if a timeout occurs, well done program.&lt;/p&gt;

&lt;p&gt;Now I&amp;rsquo;m interested to see the state of the &lt;code&gt;goroutines&lt;/code&gt; at the crash&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dlv&#34;&gt;(dlv) goroutines
[6 goroutines]
* Goroutine 1 - User: ./main.go:34 main.main (0x4952d9) (thread 32124)
  Goroutine 2 - User: /usr/lib/go/src/runtime/proc.go:288 runtime.gopark (0x42974c)
  Goroutine 3 - User: /usr/lib/go/src/runtime/proc.go:288 runtime.gopark (0x42974c)
  Goroutine 4 - User: /usr/lib/go/src/runtime/proc.go:288 runtime.gopark (0x42974c)
  Goroutine 5 - User: ./main.go:21 main.producer (0x4950b0)
  Goroutine 6 - User: /usr/lib/go/src/runtime/proc.go:288 runtime.gopark (0x42974c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nice, there where six goroutines, a few ones &lt;a href=&#34;https://github.com/golang/go/blob/7c2cf4e779a66b212a3c94f2b20ade1c2c275b84/src/runtime/proc.go#L277&#34;&gt;parked&lt;/a&gt; too&lt;/p&gt;

&lt;p&gt;Between all those goroutines the one t hat seems interesting is the Goroutine 5,
let&amp;rsquo;s see what&amp;rsquo;s inside:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dlv&#34;&gt;(dlv) goroutine 5
Switched from 1 to 5 (thread 32124)
(dlv) bt
0  0x000000000042974c in runtime.gopark
   at /usr/lib/go/src/runtime/proc.go:288
1  0x000000000042983e in runtime.goparkunlock
   at /usr/lib/go/src/runtime/proc.go:293
2  0x0000000000403c0b in runtime.chansend
   at /usr/lib/go/src/runtime/chan.go:222
3  0x0000000000403993 in runtime.chansend1
   at /usr/lib/go/src/runtime/chan.go:113
4  0x00000000004950b0 in main.producer
   at ./main.go:21
5  0x00000000004545c1 in runtime.goexit
   at /usr/lib/go/src/runtime/asm_amd64.s:2337
(dlv) frame 4 ls
Goroutine 5 frame 4 at /home/fntlnz/go/src/github.com/fntlnz/godebugging/main.go:21 (PC: 0x4950b0)
    16: }
    17:
    18: func producer(ch chan&amp;lt;- string) {
    19:         for {
    20:                 time.Sleep(time.Second * time.Duration(rand.Intn(4))) // simulate some work
=&amp;gt;  21:                 ch &amp;lt;- messages[rand.Intn(len(messages)-1)]
    22:         }
    23: }
    24:
    25: func main() {
    26:         ch := make(chan string)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When in the Goroutine 5, I can hook in the &lt;code&gt;frame 4&lt;/code&gt; to see the content of the &lt;code&gt;messages&lt;/code&gt; and &lt;code&gt;ch&lt;/code&gt; variables:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dlv&#34;&gt;(dlv) frame 4 p ch
chan&amp;lt;- string {
        qcount: 0,
        dataqsiz: 0,
        buf: *[0]string [],
        elemsize: 16,
        closed: 0,
        elemtype: *runtime._type {
                size: 16,
                ptrdata: 8,
                hash: 3774831796,
                tflag: 7,
                align: 8,
                fieldalign: 8,
                kind: 24,
                alg: *(*runtime.typeAlg)(0x5420f0),
                gcdata: *1,
                str: 6602,
                ptrToThis: 55936,},
        sendx: 0,
        recvx: 0,
        recvq: waitq&amp;lt;string&amp;gt; {
                first: *sudog&amp;lt;string&amp;gt; nil,
                last: *sudog&amp;lt;string&amp;gt; nil,},
        sendq: waitq&amp;lt;string&amp;gt; {
                first: *(*sudog&amp;lt;string&amp;gt;)(0xc4200a2000),
                last: *(*sudog&amp;lt;string&amp;gt;)(0xc4200a2000),},
        lock: runtime.mutex {key: 0},}
(dlv) frame 4 p messages
[6]string [
        &amp;quot;There&#39;s something that doesn&#39;t make sense. Let&#39;s go and poke it ...+13 more&amp;quot;,
        &amp;quot;We&#39;re all stories, in the end.&amp;quot;,
        &amp;quot;Bow ties are cool.&amp;quot;,
        &amp;quot;One may tolerate a world of demons for the sake of an angel.&amp;quot;,
        &amp;quot;You want weapons? We’re in a library! Books! The best weapons ...+13 more&amp;quot;,
        &amp;quot;Do what I do. Hold tight and pretend it’s a plan!&amp;quot;,
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With GDB things are similar, but not that nice:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gdb godebugging core.1234
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-gdb&#34;&gt;&amp;gt;&amp;gt;&amp;gt; bt
#0  runtime.raise () at /usr/lib/go/src/runtime/sys_linux_amd64.s:113
#1  0x000000000043d10b in runtime.dieFromSignal (sig=6) at /usr/lib/go/src/runtime/signal_unix.go:400
#2  0x000000000043d299 in runtime.crash () at /usr/lib/go/src/runtime/signal_unix.go:482
#3  0x00000000004281b2 in runtime.dopanic_m (gp=0xc420000180, pc=4355678, sp=842350763480) at /usr/lib/go/src/runtime/panic.go:732
#4  0x0000000000450eac in runtime.dopanic.func1 () at /usr/lib/go/src/runtime/panic.go:587
#5  0x0000000000451ff9 in runtime.systemstack () at /usr/lib/go/src/runtime/asm_amd64.s:344
#6  0x000000000042c3a0 in ?? () at /usr/lib/go/src/runtime/proc.go:1070
#7  0x0000000000544100 in runtime.sched ()
#8  0x00007fff47a3d690 in ?? ()
#9  0x0000000000544160 in ?? ()
#10 0x00007fff47a3d680 in ?? ()
#11 0x000000000042c404 in runtime.mstart () at /usr/lib/go/src/runtime/proc.go:1152
#12 0x0000000000451e21 in runtime.rt0_go () at /usr/lib/go/src/runtime/asm_amd64.s:186
#13 0x0000000000000001 in ?? ()
#14 0x00007fff47a3d6c8 in ?? ()
#15 0x0000000000000001 in ?? ()
#16 0x00007fff47a3d6c8 in ?? ()
#17 0x0000000000000000 in ?? ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A notable point here is &lt;code&gt;proc.go:1070&lt;/code&gt; so I&amp;rsquo;ll dig into that frame, also it seems that there has been a panic after.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gdb&#34;&gt;&amp;gt;&amp;gt;&amp;gt; frame 6
#6  0x000000000042c3a0 in ?? () at /usr/lib/go/src/runtime/proc.go:1070
1070	func startTheWorldWithSema() {
&amp;gt;&amp;gt;&amp;gt; l
1065	func mhelpgc() {
1066		_g_ := getg()
1067		_g_.m.helpgc = -1
1068	}
1069	
1070	func startTheWorldWithSema() {
1071		_g_ := getg()
1072	
1073		_g_.m.locks++        // disable preemption because it can be holding p in a local var
1074		gp := netpoll(false) // non-blocking
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What I see is Go code but not mine. Also given that this is a dump of a specific state and not an interactive
debugging session I cannot control the state so I can&amp;rsquo;t even inspect goroutines in such situation.&lt;/p&gt;

&lt;p&gt;The most useful thing I can do now is to get a full backtrace dump printed to a file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gdb&#34;&gt;set logging on
bt full
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates a &lt;code&gt;gdb.txt&lt;/code&gt; file in the current directory where I see that there&amp;rsquo;s a known variable I can try to print&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gdb&#34;&gt;&amp;gt;&amp;gt;&amp;gt; p main.messages
$1 = {[0] = &amp;quot;There&#39;s something that doesn&#39;t make sense. Let&#39;s go and poke it with a stick.&amp;quot;, [1] = &amp;quot;We&#39;re all stories, in the end.&amp;quot;, [2] = &amp;quot;Bow ties are cool.&amp;quot;, [3] = &amp;quot;One may tolerate a world of demons for the sake of an angel.&amp;quot;, [4] = &amp;quot;You want weapons? We’re in a library! Books! The best weapons in the world!&amp;quot;, [5] = &amp;quot;Do what I do. Hold tight and pretend it’s a plan!&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However no luck in getting the right place in my own code where the panic occurred :/&lt;/p&gt;

&lt;h2 id=&#34;the-program-runs-in-a-kubernetes-cluster&#34;&gt;The program runs in a Kubernetes cluster&lt;/h2&gt;

&lt;p&gt;In case your crashed program runs in a kubernetes cluster the good news is that you can just get
your core dumps inside the machines and analyze them like if they weren&amp;rsquo;t containers (unexpected right?).&lt;/p&gt;

&lt;p&gt;The bad news is that in case of a cluster with a number of nodes you will
need some effort to understand on which node the process crasheed and the way
to get the core dump may not be all that straightforward.&lt;/p&gt;

&lt;p&gt;However the other good news is that there&amp;rsquo;s a pull request &lt;a href=&#34;https://github.com/kubernetes/community/pull/1311&#34;&gt;kubernetes/community#1311&lt;/a&gt;
to add a crd just to do that, seems magical!&lt;/p&gt;

&lt;p&gt;In the past on this kind of distributed systems (prior to kubernetes), I was used to
write a program to be used in &lt;code&gt;/proc/sys/kernel/core/core_pattern&lt;/code&gt; that would write the dumps
to a shared filesystem, usually NFS.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How I use systemd-nspawn</title>
      <link>https://fntlnz.wtf/post/systemd-nspawn/</link>
      <pubDate>Mon, 14 Nov 2016 10:00:22 &#43;0200</pubDate>
      <author>Lorenzo Fontana</author>
      <guid>https://fntlnz.wtf/post/systemd-nspawn/</guid>
      <description>

&lt;h1 id=&#34;first-things-first&#34;&gt;First things first&lt;/h1&gt;

&lt;p&gt;About one year ago, after years with Fedora 18, I refreshed my laptop and installed a brand new Fedora 22.
My first thought went to all the mess there was before the refresh because I tried tons of applications and changed my mind thousands of times
in those three years.&lt;/p&gt;

&lt;p&gt;This time, I wanted to take my time to &lt;strong&gt;improve the process&lt;/strong&gt; and after a few minutes thinking I had a light-bulb moment and I just started creating &lt;strong&gt;a Dockerfile for every application&lt;/strong&gt; I needed !&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Well, after some time I had 27 images including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;google-chrome&lt;/li&gt;
&lt;li&gt;spotify&lt;/li&gt;
&lt;li&gt;dropbox&lt;/li&gt;
&lt;li&gt;NetworkManager&lt;/li&gt;
&lt;li&gt;pulseaudio&lt;/li&gt;
&lt;li&gt;gnome-terminal-server&lt;/li&gt;
&lt;li&gt;nautilus&lt;/li&gt;
&lt;li&gt;feh&lt;/li&gt;
&lt;li&gt;i3wm&lt;/li&gt;
&lt;li&gt;lightdm&lt;/li&gt;
&lt;li&gt;crond&lt;/li&gt;
&lt;li&gt;VirtualBox&lt;/li&gt;
&lt;li&gt;compton&lt;/li&gt;
&lt;li&gt;parcellite&lt;/li&gt;
&lt;li&gt;guake&lt;/li&gt;
&lt;li&gt;and&amp;hellip; many more!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As you can imagine, I started each one with the right options (&lt;strong&gt;I hope!&lt;/strong&gt;) allowing it to use the X server and other resources.&lt;/p&gt;

&lt;p&gt;In the next days I did some fine tuning and ended up having most of the containers I listed starting as startup system services.&lt;/p&gt;

&lt;h2 id=&#34;what-happened&#34;&gt;What happened ?&lt;/h2&gt;

&lt;p&gt;My computer &lt;strong&gt;took minutes&lt;/strong&gt; to &lt;strong&gt;undefined time&lt;/strong&gt; to boot depending on the state of the Docker daemon, and that wasn&amp;rsquo;t acceptable for me so, sad but full of hope I started thinking at a possible solution
by identifying why Docker wasn&amp;rsquo;t performing well as I expected in such situation.&lt;/p&gt;

&lt;p&gt;The main problem, wasn&amp;rsquo;t that the Docker daemon itself is slow (in fact it isn&amp;rsquo;t) but a mix of factors due to the intrinsic docker&amp;rsquo;s caracteristic that &lt;strong&gt;it wants to manage&lt;/strong&gt; everything for you, like setting up namespaces for existing containers, setting up volumes, managing and connecting to plugins, mounting the layered filesystems, setting up missing network devices and so on..&lt;/p&gt;

&lt;p&gt;All this obviously slows down startup times in certain situations and given the fact that I use docker &lt;em&gt;a lot&lt;/em&gt; for software development and for docker development itself there are a lot of ways that the state of my machine Docker daemon is pretty messy and things are likely to be broken and slow.&lt;/p&gt;

&lt;h1 id=&#34;example-container-spotify&#34;&gt;Example container: Spotify&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s say that I need to listen to some music and I&amp;rsquo;m on Fedora (looks like me now :D)&lt;/p&gt;

&lt;p&gt;I Google for the Spotify Linux client aaaaand that&amp;rsquo;s IT! Spotify does have a Linux client, great!&lt;/p&gt;

&lt;p&gt;Oh, damn, &lt;strong&gt;they only have a Debian package&lt;/strong&gt; :(&lt;/p&gt;

&lt;p&gt;&amp;hellip;Looking for possible solutions&amp;hellip;&lt;/p&gt;

&lt;p&gt;So the first thing I did was in fact to create &lt;strong&gt;a Dockerfile for spotify.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; Wait Lorenzo, but &lt;strong&gt;you&amp;rsquo;ve just said you are not using Docker&lt;/strong&gt; for your listening needs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt;: In fact &lt;strong&gt;I don&amp;rsquo;t&lt;/strong&gt;, I&amp;rsquo;m just using Docker to create a Docker image, which I will export to a tar and use as a base filesystem for my container&lt;/p&gt;

&lt;h2 id=&#34;here-s-the-dockerfile&#34;&gt;Here&amp;rsquo;s the Dockerfile:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-docker&#34;&gt;FROM debian:jessie

RUN apt-get update -y
RUN gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys BBEBDCB318AD50EC6865090613B00F1FD2C19886
RUN gpg --export --armor BBEBDCB318AD50EC6865090613B00F1FD2C19886 | apt-key add -
RUN echo deb http://repository.spotify.com stable non-free | tee /etc/apt/sources.list.d/spotify.list
RUN apt-get update -y
RUN apt-get install spotify-client -y
RUN apt-get install pulseaudio -y
RUN apt-get install -f -y
RUN echo enable-shm=no &amp;gt;&amp;gt; /etc/pulse/client.conf

ENV PULSE_SERVER /run/pulse/native
ENV HOME /home/spotify

RUN useradd --create-home --home-dir $HOME spotify \
  &amp;amp;&amp;amp; gpasswd -a spotify audio \
  &amp;amp;&amp;amp; chown -R spotify:spotify $HOME

  WORKDIR $HOME
  USER spotify
  ENTRYPOINT  [ &amp;quot;spotify&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;run-the-thing&#34;&gt;Run the thing&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -d \
  -v /etc/localtime:/etc/localtime:ro \
  -v /tmp/.X11-unix:/tmp/.X11-unix \
  -e DISPLAY=unix$DISPLAY \
  -v /run/user/1000/pulse:/run/pulse:ro \
  -v /var/lib/dbus:/var/lib/dbus \
  -v $HOME/.spotify/config:/home/spotify/.config/spotify \
  -v $HOME/.spotify/cache:/home/spotify/spotify \
  --name spotify \
  fntlnz/spotify
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that I have my image and I can use it with Docker seeing that it works I can try it with &lt;code&gt;systemd-nspawn&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The first thing to do is to export the docker image to a folder we&amp;rsquo;ll call &lt;code&gt;rootfs&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir -p /var/lib/machines
cd /var/lib/machines

mkdir spotify
docker export $(docker create fntlnz/spotify) | tar -C spotify -xvf -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we have to give the right permissions to &lt;code&gt;/home/spotify&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;systemd-nspawn -D spotify/ bash -c &amp;quot;chown -R spotify:spotify /home/spotify&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now each time we want to start that container we can do it with:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;systemd-nspawn \
  --setenv=DISPLAY=unix$DISPLAY \
  --bind=/tmp/.X11-unix:/tmp/.X11-unix \
  --bind /run/user/1000/pulse:/run/pulse \
  --bind /var/lib/dbus:/var/lib/dbus \
  -u spotify -D spotify/ \
  spotify
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;additional-notes&#34;&gt;Additional notes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;We haven&amp;rsquo;t used any layered filesystem and the container is actually writing into the &lt;code&gt;spotify&lt;/code&gt; directory.&lt;/li&gt;
&lt;li&gt;The network stack is not isolated&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;1000&lt;/strong&gt; user id needs to be changed with the id of the user connected to the X session (your user id on that machine)&lt;/li&gt;
&lt;li&gt;I&amp;rsquo;m not mounting &lt;code&gt;$HOME/.spotify&lt;/code&gt; things inside my &lt;code&gt;systemd-nspawn&lt;/code&gt; container since I decided to keep the state in the &lt;code&gt;spotify&lt;/code&gt; directory&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;machinectl&#34;&gt;machinectl&lt;/h1&gt;

&lt;p&gt;There&amp;rsquo;s another tool, invokable via &lt;code&gt;machinectl&lt;/code&gt; which allows you to manage your &amp;ldquo;machines&amp;rdquo; aka containers and vms managed
by the &lt;a href=&#34;https://wiki.freedesktop.org/www/Software/systemd/machined/&#34;&gt;&lt;strong&gt;systemd machine manager&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;container-services&#34;&gt;Container services&lt;/h2&gt;

&lt;p&gt;Using machinectl you can even create startup services, for example I use this for the NetworkManagr (image not included)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;machinectl enable network-manager
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Created symlink from /etc/systemd/system/machines.target.wants/systemd-nspawn@network-manager.service to /usr/lib/systemd/system/systemd-nspawn@.service.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;management&#34;&gt;Management&lt;/h2&gt;

&lt;p&gt;machinectl allows you to list, terminate and show the status of machines.&lt;/p&gt;

&lt;h3 id=&#34;list-all-the-machines&#34;&gt;List all the machines&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;machinectl list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MACHINE CLASS     SERVICE
spotify container nspawn 

1 machines listed.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;terminate-the-machine&#34;&gt;Terminate the machine&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;machinectl terminate spotify
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;get-the-status&#34;&gt;Get the status&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;machinectl status spotify
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;spotify
           Since: Mon 2016-11-14 02:13:54 CET; 7s ago
          Leader: 11308 (spotify)
         Service: nspawn; class container
            Root: /var/lib/machines/spotify
              OS: Debian GNU/Linux 8 (jessie)
            Unit: machine-spotify.scope
                  ├─11308 /usr/share/spotify/spotif
                  ├─11321 /usr/share/spotify/spotify --type=zygote --no-sandbox --lang=en-US --log-file=/usr/share/spotify/debug.log --log-severity=disable --product-version=Spotify/1.0.42.151
                  ├─11344 /proc/self/exe --type=gpu-process --channel=1.0.1413324922 --mojo-application-channel-token=7BA7725BB9581D934FDAECBCAC0E2C8B --no-sandbox --window-depth=24 --x11-visual-id=32 --lang=en-
                  └─11372 /usr/share/spotify/spotify --type=renderer --disable-pinch --no-sandbox --primordial-pipe-token=431AFC3F7268B33A8765213F7926A54A --lang=en-US --lang=en-US --log-file=/usr/share/spotify/

Nov 14 02:13:54 fntlnz systemd[1]: Started Container spotify.
Nov 14 02:13:54 fntlnz systemd[1]: Starting Container spotify.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;pull-images&#34;&gt;Pull images&lt;/h4&gt;

&lt;p&gt;machinectl can pull images using &lt;code&gt;pull-raw&lt;/code&gt;, &lt;code&gt;pull-tar&lt;/code&gt; and &lt;code&gt;pull-dkr&lt;/code&gt; from remote urls.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;machinectl pull-raw --verify=no http://ftp.halifax.rwth-aachen.de/fedora/linux/releases/21/Cloud/Images/x86_64/Fedora-Cloud-Base-20141203-21.x86_64.raw.xz
systemd-nspawn -M Fedora-Cloud-Base-20141203-21
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for more, see &lt;a href=&#34;https://www.freedesktop.org/software/systemd/man/machinectl.html&#34;&gt;machinectl&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;what-s-next&#34;&gt;What&amp;rsquo;s next&lt;/h1&gt;

&lt;p&gt;In this post I showed you something like the top 1% of the things that can be done with &lt;code&gt;systemd-nspawn&lt;/code&gt;, there&amp;rsquo;s &lt;strong&gt;moar!!&lt;/strong&gt;, like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Usage of btrfs as container root and ephemeral containers&lt;/li&gt;
&lt;li&gt;Network isolation and advanced network interfaces (macvlan, ipvlan)&lt;/li&gt;
&lt;li&gt;Integration with SELinux&lt;/li&gt;
&lt;li&gt;bootable images&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;see &lt;code&gt;man machinectl&lt;/code&gt; and &lt;code&gt;man systemd-nspawn&lt;/code&gt; for more&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;what-i-achieved&#34;&gt;What I achieved ?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Portability and zero setup time&lt;/strong&gt;: most linux distributions today are using systemd that means that my containers will work without having to install anything&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Faster startup times&lt;/strong&gt;: as I said, starting just a process is faster than setting up a Docker container, not because Docker is slow (it&amp;rsquo;s not) but because it does actually more than just starting the process&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reuse&lt;/strong&gt;: I can reuse any docker image I want just by exporting it to a tar file, I can even reuse virtual machine images.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now let&amp;rsquo;s listen some music!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://fntlnz.wtf/systemd-nspawn/video.gif&#34; alt=&#34;systemd nspawn spotify&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why do we have containers</title>
      <link>https://fntlnz.wtf/post/why-containers/</link>
      <pubDate>Thu, 11 Aug 2016 15:35:53 CEST</pubDate>
      <author>Lorenzo Fontana</author>
      <guid>https://fntlnz.wtf/post/why-containers/</guid>
      <description>

&lt;h1 id=&#34;disclaimer&#34;&gt;Disclaimer&lt;/h1&gt;

&lt;p&gt;This post reflects my own view of the whole world of virtualization, I summed up here my thoughts but please
if you find something that you consider wrong or inexact leave a comment so I can learn by you and improve myself.&lt;/p&gt;

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;While talking about Linux Containers, Docker Containers or more in general about the &lt;strong&gt;concept of containers itself&lt;/strong&gt; I often (as it should be) encounter doubts and questions like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What is the actual difference between containers and other types of virtualization?&lt;/li&gt;
&lt;li&gt;How are containers going to make my life better?&lt;/li&gt;
&lt;li&gt;What should I say to my security team while I&amp;rsquo;m using those containers?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All this can be summarized in a more simple question:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Why do we have containers ? What we had before was not enough?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In this post I want to try to explain why, in my opinion, &lt;strong&gt;OS Level Virtualization&lt;/strong&gt; (aka. containers) is a thing that matters now
primarily by analyzing the details of each virtualization method.&lt;/p&gt;

&lt;h1 id=&#34;different-types-of-virtualization&#34;&gt;Different types of virtualization&lt;/h1&gt;

&lt;p&gt;At the moment there are three main distinct types of Virtualization, namely:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Full Virtualization&lt;/li&gt;
&lt;li&gt;Paravirtualization&lt;/li&gt;
&lt;li&gt;OS Level Virtualization (Containers)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The most interesting one for the discussion is the last one but is important to understand that at some extent all types have two common denominators:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://fntlnz.wtf/why-containers/Virtualization.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A Host: the primary operating system where the Docker daemon is running, where KVM is running, where VMware is running&lt;/li&gt;
&lt;li&gt;A Guest: the actual container or virtual machine&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The main difference between all those types of virtualization is the level at which them interact with the underlying resources and devices
thus is responsible for their difference in terms of security, resources usage and portability.&lt;/p&gt;

&lt;p&gt;This discussion can be easily understood in the context of load balancers where there two types of them: Hardware and software load balancers,
both do load balancing and while the hardware version typically provides improved performances this comes at the cost of another specific piece of hardware with the limitations of the case.
as opposite, software load balancers can be installed on any hardware, are more portable, customizable and probably fits better specific needs.&lt;/p&gt;

&lt;p&gt;Given all this, there are a few areas of differentiation between all the different types of virtualization:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Security&lt;/strong&gt;: Having a full operating system with its own kernel may seem a source of additional security because of the fact
that is nearly impossible to escape from virtual machines. But if you consider the fact that you are putting a &lt;strong&gt;brand new kernel, with its vulnerabilities
and bugs&lt;/strong&gt; on top of your existing kernel you may change your point of view. On the other hand, OS-Level virtualization share the same kernel with the host operating system
but comes with a larger surface for possible attackers due to the syscalls, shared networking, device and disk access. Anyway don&amp;rsquo;t worry most of these security issues are
solved in most used OS-Level virtualization platforms such as Docker, in fact Docker Containers for example are fully integrated with cgroups, seccomp, SELinux, and all the possible resources
are isolated properly using Kernel namespaces, also you can manually add or drop capabilities.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Portability&lt;/strong&gt;: Full virtualization and paravirtualization both leverages on specific hardware, because of its nature requires more resources than
OS-Level virtuanchorlinenosalization which can be used anywhere a modern Linux kernel is present.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Speed&lt;/strong&gt;: The fact that OS-Level virtualization works in a shared kernel architecture offers super fast startup times, this is not true for other types of virtualization
where starting a new system is a lot more than just spawning a new process as it is with containers.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Application Portability&lt;/strong&gt;: as because containers can be moved easily due to their decreased size due to the fact that they don&amp;rsquo;t own an entire operating system and a kernel
we can obtain &lt;strong&gt;reduced downtimes&lt;/strong&gt; and avoid headaches. For other types of virtualization this is not true, we all know that moving a virtual machine to another
host requires lots of bandwidth and storage.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Storage&lt;/strong&gt;: given that OS-Level virtualization implies the fact that the kernel is shared usually there&amp;rsquo;s an implemented Copy on Write filesystem and Union Filesystem
to put all the pieces toghether and obtain containers that only owns their code, components and libraries.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Live Migration&lt;/strong&gt;: Some OS-Level virtualization platform such as OpenVZ does support live migrations, most Fill virtualization platforms supports it. Docker containers on the
other hand does not have an official implementation for this&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;motivations-for-using-containers&#34;&gt;Motivations for using Containers&lt;/h2&gt;

&lt;p&gt;I can&amp;rsquo;t know what is your intended use case.
But if at some extent your motivation consist in &lt;strong&gt;decreasing costs&lt;/strong&gt; related to full virtualization overheads
while &lt;strong&gt;allowing developers to ship, develop and test code faster&lt;/strong&gt; we already found two.&lt;/p&gt;

&lt;h2 id=&#34;in-the-end-why-containers-are-actually-there&#34;&gt;In the end, why containers are actually there?&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;v read up to here you probably think I missed the point, instead what I wanted to write is exactly that
OS-Level virtualization (aka containers) is just another way of doing virtualization which solves specific needs that are not solved by others:&lt;/p&gt;

&lt;p&gt;We need containers for being able to work closer to the kernel while executing in a fully isolated environment.
This specific thing allows us to achieve &lt;strong&gt;higher densities&lt;/strong&gt; and run more workload within the same hardware while
obtaining &lt;strong&gt;faster delivery and scaling&lt;/strong&gt; thanks to their nature of high portability.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
